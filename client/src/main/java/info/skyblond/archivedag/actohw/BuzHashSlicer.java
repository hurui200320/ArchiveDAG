package info.skyblond.archivedag.actohw;

import io.ipfs.multihash.Multihash;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;

/**
 * BuzHash slicer, or, Cyclic polynomial hash.
 * Use BuzHash fingerprint to decide the chunk border.
 */
public class BuzHashSlicer extends RollingHashSlicer {

    /**
     * Generated by "cat /dev/random | hexdump | head -n 64".
     */
    public static final int[] DEFAULT_HASHTABLE = new int[]{
            0xecf47c0f, 0xc442a7f6, 0xda062169, 0x7d99b468,
            0x8138cfdb, 0xf9100379, 0x32777646, 0x978ce15c,
            0x3297981a, 0x135e1e58, 0x1cd57914, 0x0b3079a6,
            0x5bdeb1c4, 0x1787f5d4, 0xef877ff5, 0xcf623a74,
            0x7d75200f, 0x0b250756, 0x2975d85d, 0xfbb2a198,
            0x318d4ef5, 0x08a5d1d0, 0x5c880b58, 0xb5689399,
            0x7d1304d3, 0x75770958, 0xd7aee914, 0xc6b2405f,
            0x02360c87, 0x92070a6c, 0xd361fd82, 0xb49a10f9,
            0x1551eafe, 0xfe9bda9d, 0x6c5619f8, 0x76f358b4,
            0x22d2e5ab, 0x82eebdb1, 0xf6e170c8, 0xd7a2f76d,
            0x419cffe9, 0xb275153c, 0xefede548, 0x2e1fb600,
            0x9e8dba08, 0xdc277ec0, 0x9b2a9556, 0x19c0593e,
            0x324a6c52, 0xe287954c, 0xcba27082, 0xb2c3692f,
            0x0ad04cd1, 0x0fc7a7e2, 0x5145a62f, 0x2f6b3a7a,
            0xbc5cc3fc, 0xbb692eec, 0x04ecd5f1, 0xc29111a5,
            0xb450d035, 0x544bf438, 0xacfad033, 0xd26a7efc,
            0x7aa8e3db, 0xf1e02d07, 0x0bfbad14, 0x7f59bea1,
            0xb8db39e2, 0x0c4223c2, 0x7f06358d, 0xa7c6af60,
            0xcc5571d3, 0xfb4bcee3, 0x1ef3b5e5, 0x7ea9624a,
            0x71348022, 0x37f29fe3, 0x629bd532, 0x10d47274,
            0xf1eb3fcc, 0x4bf81993, 0x8ee8ce27, 0x9be87cc2,
            0xf32c04bf, 0x9e527290, 0xf870039a, 0xa92aa34a,
            0xc3437532, 0x7e55bbb1, 0xce7864df, 0x2879d574,
            0xbe5e94ad, 0x6baa39c8, 0x34bf1a26, 0xafbb2101,
            0x775049e3, 0xda0df8f9, 0xbf14d54e, 0x66616d34,
            0x83ad5e10, 0x98ba7ac0, 0x58e58a6b, 0xf0cb81d6,
            0x487d9846, 0xab52f739, 0x7c0941ef, 0xc15f0ff2,
            0xa4a21833, 0x75c7aa3b, 0x06e9aa94, 0x2c270438,
            0x6964cd00, 0xa16da32e, 0xfaa70687, 0xa63d7c95,
            0x614b66d2, 0xcea95fd5, 0x530ac35c, 0x73848495,
            0xc7c7ceeb, 0x817d93f1, 0x48c750ca, 0x91aef245,
            0xc32e1eb6, 0x28a87182, 0xde20858b, 0x9fdb6e64,
            0xdb4e255d, 0x161957e5, 0xf6890fb0, 0x1474bade,
            0xac2fe70d, 0x49ab8808, 0x0dbac969, 0xd0768578,
            0x6e22fc45, 0xde0849b5, 0xfb11dfa5, 0x7de3dc01,
            0x783d8a9b, 0xeb258f07, 0x015a4270, 0xeb33a51b,
            0x56aa94e7, 0x85bfa26b, 0x109a2e82, 0x6c7e6530,
            0x0c1036bd, 0x2ef847d6, 0x8f1b564a, 0xc53da6f5,
            0x3c4b41b2, 0x491f6736, 0xe32c5fea, 0x76c4fc38,
            0x5161c3dc, 0x36e31b0e, 0xda65d709, 0x5dd12619,
            0x77f4d693, 0x4bb11090, 0x45ad8d49, 0xeef7b5af,
            0x0680dc1b, 0xcc951f13, 0xd9f2c9d8, 0xb61f1563,
            0x9efca81f, 0xd4e560ba, 0x077032f7, 0x29934f40,
            0x885bf968, 0x5ba1c52e, 0x2b319e14, 0x7a98eb25,
            0x631029de, 0xab12aa81, 0x54975b9f, 0x5e71ef80,
            0x896e38de, 0x7748e63d, 0xc1b43ccf, 0xcc71caa5,
            0xccc67c3d, 0x53d0c996, 0x0b125620, 0xe0232bd4,
            0x0aaec0d9, 0x3eaffd75, 0x93f8576e, 0x8bca78e0,
            0xf1b1493b, 0x6f62ecde, 0x557c9131, 0xd9593dd3,
            0xf1544c5e, 0xbd9db656, 0xb6f1cb02, 0xcbfc66b7,
            0x21f15546, 0x1f8483be, 0x29b09e03, 0xa3e5e0d6,
            0x26737a9c, 0x76963927, 0x610f7472, 0x4e8e220f,
            0x293c50e1, 0xf60ba7a2, 0x76b649c5, 0x62fcf8ac,
            0x952f6e5e, 0x2882fc17, 0xca4ba832, 0x9c2352a9,
            0xa643a89f, 0x815c6fa0, 0xd2c48252, 0xd363b441,
            0x2bd49c14, 0x47305858, 0x683333ac, 0x6b826199,
            0x069982a6, 0xcf9ae702, 0x03e97d45, 0xe9181ef1,
            0xcca3d9b5, 0x35d81b24, 0x84caa7cf, 0x294be0d6,
            0x407c8183, 0xbf91157b, 0x47f4ac4d, 0x1ea89ddd,
            0x9df210e7, 0x2b713677, 0x497b4e59, 0x778a1d5a,
            0xcab70628, 0x937bf861, 0xbe8f4e84, 0x2351f9fb,
            0x18b23389, 0xfd1bc6dd, 0x0db0f481, 0xe2d47f39,
            0x386e8d3a, 0xe353a0b8, 0xa97f8b3d, 0x218fa082,
            0xc8176a6f, 0x750f8c0c, 0x885d24ba, 0x48f7acd8
    };

    /**
     * Window size, aka the `N`.
     */
    private final int windowSize; // windowSize, aka the `N`

    /**
     * Window buffer. For computation, it's int rather than byte.
     */
    private final int[] windowBuffer;

    /**
     * Window buffer pointer. Indicate current position.
     */
    private int windowBufferPtr;

    private final int[] hashTable;

    public BuzHashSlicer(
            Path workDir, Multihash.Type primaryHashType, Multihash.Type secondaryHashType,
            int fingerprintMask, int fingerprint, int minChunkSize, int maxChunkSize,
            int windowChannelBufferSize, ExecutorService executorService,
            int[] hashTable, int windowSize
    ) {
        super(workDir, primaryHashType, secondaryHashType,
                fingerprintMask, fingerprint, minChunkSize, maxChunkSize,
                windowChannelBufferSize, executorService
        );
        this.windowSize = windowSize;
        this.windowBuffer = new int[this.windowSize];
        this.windowBufferPtr = 0;
        this.hashTable = hashTable;
        if (this.hashTable.length != 256) {
            throw new IllegalArgumentException("The hashtable must has 256 elements");
        }
        if (Arrays.stream(this.hashTable).distinct().count() != 256) {
            throw new IllegalArgumentException("Duplicated elements found in hashtable");
        }
    }

    private int s(int x, int k) {
        return (x << k) | (x >>> (Integer.SIZE - k));
    }

    @Override
    protected int initHash() throws IOException {
        this.hash = 0;
        this.windowBufferPtr = 0;
        for (int i = 0; i < this.windowSize; i++) {
            int b = this.readNextWindowByte();
            // save the content
            this.windowBuffer[this.windowBufferPtr++] = b;
            this.windowBufferPtr %= this.windowSize;
            // hash' = s(hash, 1) XOR h(b)
            this.hash = this.s(this.hash, 1) ^ this.hashTable[b];
        }
        return this.windowSize;
    }

    /**
     * Calculate next hash.
     */
    @Override
    protected void calcNextHash() throws IOException {
        int in = this.readNextWindowByte();
        // hash' = s(hash, 1) XOR s(h(out), N) XOR h(in)
        int out = this.windowBuffer[this.windowBufferPtr];
        this.hash = this.s(this.hash, 1) ^ this.s(this.hashTable[out], this.windowSize) ^ this.hashTable[in];
        // save the input byte to buffer and move to next one
        this.windowBuffer[this.windowBufferPtr++] = in;
        this.windowBufferPtr %= this.windowSize;
    }

    @Override
    protected void reset(File file) {
        if (this.getTotalBytes() <= this.windowSize) {
            throw new IllegalArgumentException("Input file is too small");
        }
    }

    @Override
    protected void onFinished() {
    }
}
